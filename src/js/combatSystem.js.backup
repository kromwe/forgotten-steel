// Combat system for handling enemy encounters

export class CombatSystem {
  constructor(gameState, terminal, storyEngine) {
    this.gameState = gameState;
    this.terminal = terminal;
    this.storyEngine = storyEngine;
    
    this.inCombat = false;
    this.currentEnemy = null;
    this.playerTurn = true;
    
    this.initializeCommandHandlers();
  }
  
  initializeCommandHandlers() {
    // Attack command during combat
    this.terminal.registerCommand('^(attack|fight|hit|strike)$', () => {
      if (this.inCombat && this.playerTurn) {
        this.playerAttack();
      } else if (!this.inCombat) {
        this.terminal.print("There's nothing to attack right now.", 'error-message');
      } else {
        this.terminal.print("It's not your turn to attack.", 'error-message');
      }
    });
    
    // Defend command during combat
    this.terminal.registerCommand('^(defend|block|parry)$', () => {
      if (this.inCombat && this.playerTurn) {
        this.playerDefend();
      } else if (!this.inCombat) {
        this.terminal.print("There's no need to defend right now.", 'error-message');
      } else {
        this.terminal.print("It's not your turn to defend.", 'error-message');
      }
    });
    
    // Use item during combat
    this.terminal.registerCommand('^(use) (.+)$', (input) => {
      if (this.inCombat && this.playerTurn) {
        const itemName = input.match(/^use\s+(.+)$/i)[1].toLowerCase();
        this.useItemInCombat(itemName);
      } else if (!this.inCombat) {
        // Let the story engine handle normal item use
        return false; // Don't handle the command here
      } else {
        this.terminal.print("It's not your turn to use an item.", 'error-message');
      }
    });
    
    // Flee command during combat
    this.terminal.registerCommand('^(flee|escape|run)$', () => {
      if (this.inCombat && this.playerTurn) {
        this.attemptFlee();
      } else if (!this.inCombat) {
        this.terminal.print("There's nothing to flee from right now.", 'error-message');
      } else {
        this.terminal.print("It's not your turn to flee.", 'error-message');
      }
    });
  }
  
  initiateCombat(enemy) {
    this.inCombat = true;
    this.currentEnemy = enemy;
    this.playerTurn = true;
    
    // Display combat start message
    this.terminal.print(`\n--- COMBAT STARTED ---`, 'combat-header');
    this.terminal.print(`You are fighting ${enemy.name}!`, 'combat-start');
    this.terminal.print(enemy.combatDescription || enemy.description, 'combat-description');
    
    // Display enemy stats
    this.terminal.print(`${enemy.name}'s Health: ${enemy.health}/${enemy.maxHealth}`, 'enemy-stats');
    
    // Display player stats
    this.terminal.print(`Your Health: ${this.gameState.health}/${this.gameState.maxHealth}`, 'player-stats');
    
    // Display available combat actions
    this.showCombatActions();
  }
  
  showCombatActions() {
    this.terminal.print("\nAvailable actions:", 'combat-actions-header');
    this.terminal.print("- attack: Attack the enemy", 'combat-action');
    this.terminal.print("- defend: Take a defensive stance to reduce damage", 'combat-action');
    this.terminal.print("- use [item]: Use an item from your inventory", 'combat-action');
    this.terminal.print("- flee: Attempt to escape from combat", 'combat-action');
  }
  
  playerAttack() {
    // Calculate player damage
    let baseDamage = 5; // Base unarmed damage
    let damageMultiplier = 1.0;
    
    // Add weapon damage if equipped
    if (this.gameState.equippedWeapon) {
      baseDamage = this.gameState.equippedWeapon.damage || 10;
      
      // Apply weapon-specific effects
      if (this.gameState.equippedWeapon.effects) {
        for (const effect of this.gameState.equippedWeapon.effects) {
          if (effect.type === 'damageMultiplier') {
            damageMultiplier *= effect.value;
          }
        }
      }
    }
    
    // Apply random variation (80% to 120% of base damage)
    const randomFactor = 0.8 + Math.random() * 0.4;
    
    // Calculate final damage
    const damage = Math.floor(baseDamage * damageMultiplier * randomFactor);
    
    // Apply damage to enemy
    this.currentEnemy.health -= damage;
    
    // Display attack message
    if (this.gameState.equippedWeapon) {
      this.terminal.print(`You attack ${this.currentEnemy.name} with your ${this.gameState.equippedWeapon.name}, dealing ${damage} damage!`, 'player-attack');
    } else {
      this.terminal.print(`You attack ${this.currentEnemy.name} with your bare hands, dealing ${damage} damage!`, 'player-attack');
    }
    
    // Check if enemy is defeated
    if (this.currentEnemy.health <= 0) {
      this.enemyDefeated();
      return;
    }
    
    // Switch to enemy turn
    this.playerTurn = false;
    this.terminal.print(`${this.currentEnemy.name}'s Health: ${this.currentEnemy.health}/${this.currentEnemy.maxHealth}`, 'enemy-stats');
    
    // Enemy attacks after a short delay
    setTimeout(() => this.enemyTurn(), 1500);
  }
  
  playerDefend() {
    // Set defensive stance
    this.defending = true;
    
    this.terminal.print("You take a defensive stance, preparing to block the next attack.", 'player-defend');
    
    // Switch to enemy turn
    this.playerTurn = false;
    
    // Enemy attacks after a short delay
    setTimeout(() => this.enemyTurn(), 1500);
  }
  
  useItemInCombat(itemName) {
    // Find the item in inventory
    for (const item of this.gameState.inventory) {
      if (item.keywords.some(keyword => itemName.includes(keyword))) {
        // Check if item can be used in combat
        if (item.usableInCombat === false) {
          this.terminal.print(`You can't use the ${item.name} during combat.`, 'error-message');
          return;
        }
        
        // Check if item has a combat use handler
        if (item.onCombatUse) {
          const result = item.onCombatUse(this.gameState, this.terminal, this.currentEnemy, this);
          
          // If the item use was successful and should consume a turn
          if (result !== false) {
            // Switch to enemy turn
            this.playerTurn = false;
            
            // Check if enemy is defeated (might happen from item use)
            if (this.currentEnemy.health <= 0) {
              this.enemyDefeated();
              return;
            }
            
            // Enemy attacks after a short delay
            setTimeout(() => this.enemyTurn(), 1500);
          }
          
          return;
        } else if (item.onUse) {
          // Fall back to regular use if no combat-specific handler
          const result = item.onUse(this.gameState, this.terminal, this.storyEngine);
          
          // If the item use was successful and should consume a turn
          if (result !== false) {
            // Switch to enemy turn
            this.playerTurn = false;
            
            // Check if enemy is defeated (might happen from item use)
            if (this.currentEnemy.health <= 0) {
              this.enemyDefeated();
              return;
            }
            
            // Enemy attacks after a short delay
            setTimeout(() => this.enemyTurn(), 1500);
          }
          
          return;
        } else {
          this.terminal.print(`You're not sure how to use the ${item.name} in combat.`, 'error-message');
          return;
        }
      }
    }
    
    this.terminal.print(`You don't have any ${itemName} to use.`, 'error-message');
  }
  
  attemptFlee() {
    // Calculate flee chance based on enemy's speed vs player's
    const enemySpeed = this.currentEnemy.speed || 5;
    let playerSpeed = 5; // Base speed
    
    // Adjust for armor (heavier armor reduces speed)
    if (this.gameState.equippedArmor) {
      playerSpeed -= (this.gameState.equippedArmor.speedPenalty || 0);
    }
    
    // Calculate flee chance (50% base + adjustment for speed difference)
    const fleeChance = 0.5 + (playerSpeed - enemySpeed) * 0.05;
    
    // Attempt to flee
    if (Math.random() < fleeChance) {
      // Successful flee
      this.terminal.print("You successfully escape from combat!", 'combat-flee');
      this.endCombat();
    } else {
      // Failed flee attempt
      this.terminal.print(`You try to escape, but ${this.currentEnemy.name} blocks your path!`, 'combat-flee-fail');
      
      // Switch to enemy turn (fleeing costs a turn even if unsuccessful)
      this.playerTurn = false;
      
      // Enemy attacks after a short delay
      setTimeout(() => this.enemyTurn(), 1500);
    }
  }
  
  enemyTurn() {
    // Calculate enemy damage
    let baseDamage = this.currentEnemy.damage || 5;
    
    // Apply random variation (80% to 120% of base damage)
    const randomFactor = 0.8 + Math.random() * 0.4;
    
    // Calculate damage reduction from armor
    let damageReduction = 0;
    if (this.gameState.equippedArmor) {
      damageReduction = this.gameState.equippedArmor.protection || 0;
    }
    
    // Additional damage reduction if defending
    if (this.defending) {
      damageReduction += 5;
      this.terminal.print("Your defensive stance reduces the incoming damage!", 'combat-defend');
      this.defending = false; // Reset defending status
    }
    
    // Calculate final damage (minimum 1)
    const damage = Math.max(1, Math.floor((baseDamage * randomFactor) - damageReduction));
    
    // Apply damage to player
    this.gameState.health -= damage;
    
    // Display attack message
    this.terminal.print(`${this.currentEnemy.name} attacks you, dealing ${damage} damage!`, 'enemy-attack');
    this.terminal.print(`Your Health: ${this.gameState.health}/${this.gameState.maxHealth}`, 'player-stats');
    
    // Check if player is defeated
    if (this.gameState.health <= 0) {
      this.gameState.health = 0;
      this.playerDefeated();
      return;
    }
    
    // Switch back to player turn
    this.playerTurn = true;
    
    // Show available actions
    this.showCombatActions();
  }
  
  enemyDefeated() {
    this.terminal.print(`\nYou have defeated ${this.currentEnemy.name}!`, 'combat-victory');
    
    // Check for rewards
    if (this.currentEnemy.rewards) {
      // Handle experience or stat increases
      if (this.currentEnemy.rewards.healthIncrease) {
        this.gameState.maxHealth += this.currentEnemy.rewards.healthIncrease;
        this.gameState.health += this.currentEnemy.rewards.healthIncrease;
        this.terminal.print(`Your maximum health increases by ${this.currentEnemy.rewards.healthIncrease}!`, 'reward');
      }
      
      // Handle item rewards
      if (this.currentEnemy.rewards.items) {
        for (const itemId of this.currentEnemy.rewards.items) {
          const item = this.storyEngine.items[itemId];
          if (item) {
            this.gameState.addToInventory({
              id: itemId,
              ...item
            });
            this.terminal.print(`You found: ${item.name}`, 'reward');
          }
        }
      }
    }
    
    // Handle post-combat events
    if (this.currentEnemy.onDefeat) {
      this.currentEnemy.onDefeat(this.gameState, this.terminal, this.storyEngine);
    }
    
    // End combat
    this.endCombat();
  }
  
  playerDefeated() {
    this.terminal.print("\nYou have been defeated!", 'combat-defeat');
    
    // Handle player death
    if (this.currentEnemy.onPlayerDefeat) {
      this.currentEnemy.onPlayerDefeat(this.gameState, this.terminal, this.storyEngine);
    } else {
      // Default game over handling
      this.terminal.print("\nGAME OVER", 'game-over');
      this.terminal.print("You can reload a saved game or start a new game.", 'game-over-message');
      
      // Disable the terminal input
      this.terminal.disable();
      
      // Show game over screen or options
      document.getElementById('game-over-screen').style.display = 'flex';
    }
    
    // End combat
    this.endCombat();
  }
  
  endCombat() {
    this.inCombat = false;
    this.currentEnemy = null;
    this.playerTurn = false;
    this.defending = false;
    
    this.terminal.print("\n--- COMBAT ENDED ---", 'combat-header');
  }
}